# 코드 정리의 일괄 처리량

## 통합과 배포 전 코드 정리의 크기

일괄 처리하는 코드가 너무 많은 경우와 너무 적은 경우 그리고 적절한 경우의 범위를 판단할 때, 고려할 만한 비용에는 다음과 같은 것들이 포함된다

### 충돌

일괄 처리하는 코드 정리 작업이 많아진다

- 통합 과정에서 지연되는 시간이 길어진다
- 다른 사람의 작업과 충돌할 가능성도 커진다
- 작업을 병합하는 비용 또한 큰 폭으로 증가한다

### 상호작용

다수의 코드 정리를 한번에 처리하다가 우연히 동작 변경을 할 수도 있다

- 코드 정리 사이에 상호 작용이 있으면 병합 비용은 급격히 증가한다

### 추측

한 번에 처리하는 코드 정리가 많을수록 자연스럽게 더 많은 코드를 정리하게 된다

- 그로 인해 예상치 못한 추가 비용이 발생한다

이러한 요인으로 인해 코드 정리 개수를 줄인 후 통합 과정을 거치는 것이 일반적이다. 하지만 대량의 코드 정리를 일괄로 처리하는 경우가 많아진다

## 검토하고 배포하는 데 드는 고정비용

> 많은 조직에서 하나의 변경 사항을 검토하고 배포하는 데 드는 고정 비용은 상당히 많습니다.

(PR을 쪼개면서 발생하는 비용과 많은 PR과 관련된 CI/CD나 vercel preview같은 것들을 고정비용으로 표기한다고 이해됩니다)

그래서 타협점을 찾으려고 한다

하지만, 결국 코드 정리는 동작 변경을 수월하게 하기 위한 도구이기 때문에 더 많은 개수의 코드정리로 동작 변경에 소용되는 비용을 줄이면 된다. 그렇게 된다면 결국에는 기능 변경에 대한 검토 비용을 줄일 수 있게 된다.
(너무 어려운 코드를 정리와 변경의 코드로 구분함으로서 변경의 검토시에 깔끔하게 변경점이 보이도록 검토 요청을 할 수 있다)

### 검토 비용을 제대로 줄일 수 있는 이상적인 방법

팀에 신로와 강력한 문화가 있다면 코드 정리 후에는 굳이 검토할 필요가 없다. 검토하지 않더라도 코드 정리가 소프트웨어 안정을 해치지 않으면 상호작용의 위험이 줄어든다.
(값의 영역이 아닌 온전한 타입 시스템의 영역에 있는 아이들이라면 검토가 없어도 위험은 적다)

코드 정리 검토를 없앨 수준의 안전과 신뢰에 도달하려면, 적어도 몇 달이 걸린다.
(그런데 구성원이나 팀이 바뀐다면...?)

## 참고

[골디락스의 딜레마](https://en.wikipedia.org/wiki/Goldilocks_principle)
